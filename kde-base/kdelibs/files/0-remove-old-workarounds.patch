diff --git a/solid/solid/backends/udisks2/udisksopticaldisc.cpp b/solid/solid/backends/udisks2/udisksopticaldisc.cpp
index 23a4fc1..f1d9bce 100644
--- a/solid/solid/backends/udisks2/udisksopticaldisc.cpp
+++ b/solid/solid/backends/udisks2/udisksopticaldisc.cpp
@@ -33,11 +33,6 @@
 
 #include "udisks2.h"
 #include "udisksopticaldisc.h"
-#include "soliddefs_p.h"
-
-typedef QMap<QByteArray, Solid::OpticalDisc::ContentTypes> ContentTypesCache;
-SOLID_GLOBAL_STATIC(ContentTypesCache, cache)
-SOLID_GLOBAL_STATIC(QMutex, cacheLock)
 
 // inspired by http://cgit.freedesktop.org/hal/tree/hald/linux/probing/probe-volume.c
 static Solid::OpticalDisc::ContentType advancedDiscDetect(const QByteArray & device_file)
@@ -173,7 +168,7 @@ out:
 using namespace Solid::Backends::UDisks2;
 
 OpticalDisc::OpticalDisc(Device *dev)
-    : StorageVolume(dev), m_needsReprobe(true), m_cachedContent(Solid::OpticalDisc::NoContent)
+    : StorageVolume(dev)
 {
     UdevQt::Client client(this);
     m_udevDevice = client.deviceByDeviceFile(device());
@@ -181,8 +176,6 @@ OpticalDisc::OpticalDisc(Device *dev)
     /*qDebug() << "\tProperties:" << */ m_udevDevice.deviceProperties(); // initialize the properties DB so that it doesn't crash further down, #298416
 
     m_drive = new Device(m_device->drivePath());
-    QDBusConnection::systemBus().connect(UD2_DBUS_SERVICE, m_drive->udi(), DBUS_INTERFACE_PROPS, "PropertiesChanged", this,
-                                         SLOT(slotDrivePropertiesChanged(QString,QVariantMap,QStringList)));
 }
 
 OpticalDisc::~OpticalDisc()
@@ -245,23 +238,10 @@ Solid::OpticalDisc::DiscType OpticalDisc::discType() const
 
 Solid::OpticalDisc::ContentTypes OpticalDisc::availableContent() const
 {
-    if (isBlank()) {
-        m_needsReprobe = false;
-        return Solid::OpticalDisc::NoContent;
-    }
-
-    if (m_needsReprobe) {
-        QMutexLocker lock(cacheLock);
-
+    Solid::OpticalDisc::ContentTypes m_cachedContent = Solid::OpticalDisc::NoContent;
+    if (!isBlank()) {
         const QByteArray deviceFile = m_device->prop("Device").toByteArray();
 
-        if (cache->contains(deviceFile)) {
-            m_cachedContent = cache->value(deviceFile);
-            m_needsReprobe = false;
-            return m_cachedContent;
-        }
-
-        m_cachedContent = Solid::OpticalDisc::NoContent;
         const bool hasData = m_drive->prop("OpticalNumDataTracks").toUInt() > 0;
         const bool hasAudio = m_drive->prop("OpticalNumAudioTracks").toUInt() > 0;
 
@@ -271,26 +251,11 @@ Solid::OpticalDisc::ContentTypes OpticalDisc::availableContent() const
         }
         if ( hasAudio )
             m_cachedContent |= Solid::OpticalDisc::Audio;
-
-        m_needsReprobe = false;
-        cache->insert(deviceFile, m_cachedContent);
     }
 
     return m_cachedContent;
 }
 
-void OpticalDisc::slotDrivePropertiesChanged(const QString &ifaceName, const QVariantMap &changedProps, const QStringList &invalidatedProps)
-{
-    Q_UNUSED(ifaceName);
-
-    if (changedProps.keys().contains("Media") || invalidatedProps.contains("Media")) {
-        QMutexLocker lock(cacheLock);
-        m_needsReprobe = true;
-        m_cachedContent = Solid::OpticalDisc::NoContent;
-        cache->remove(m_device->prop("Device").toByteArray());
-    }
-}
-
 QString OpticalDisc::media() const
 {
     return m_drive->prop("Media").toString();
diff --git a/solid/solid/backends/udisks2/udisksopticaldisc.h b/solid/solid/backends/udisks2/udisksopticaldisc.h
index 0cdcc66..56b8a2f 100644
--- a/solid/solid/backends/udisks2/udisksopticaldisc.h
+++ b/solid/solid/backends/udisks2/udisksopticaldisc.h
@@ -52,13 +52,8 @@ public:
     virtual Solid::OpticalDisc::DiscType discType() const;
     virtual Solid::OpticalDisc::ContentTypes availableContent() const;
 
-private Q_SLOTS:
-    void slotDrivePropertiesChanged(const QString & ifaceName, const QVariantMap & changedProps, const QStringList & invalidatedProps);
-
 private:
     QString media() const;
-    mutable bool m_needsReprobe;
-    mutable Solid::OpticalDisc::ContentTypes m_cachedContent;
     Device * m_drive;
     UdevQt::Device m_udevDevice;
 };
