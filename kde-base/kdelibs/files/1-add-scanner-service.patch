diff --git a/solid/solid/CMakeLists.txt b/solid/solid/CMakeLists.txt
index 08953fe..23f53a2 100644
--- a/solid/solid/CMakeLists.txt
+++ b/solid/solid/CMakeLists.txt
@@ -278,6 +278,7 @@ if(NOT WIN32 AND NOT APPLE)
        if ( WITH_SOLID_UDISKS2 )
            message(STATUS "Building Solid UDisks2 backend." )
            add_definitions(-DWITH_SOLID_UDISKS2)
+           add_subdirectory(diskscan)
            set(solid_LIB_SRCS ${solid_LIB_SRCS}
            backends/udisks2/udisksmanager.cpp
            backends/udisks2/udisksdevice.cpp
diff --git a/solid/solid/backends/udisks2/udisksopticaldisc.h b/solid/solid/backends/udisks2/udisksopticaldisc.h
index 0cdcc66..8dd0bc0 100644
--- a/solid/solid/backends/udisks2/udisksopticaldisc.h
+++ b/solid/solid/backends/udisks2/udisksopticaldisc.h
@@ -52,15 +52,11 @@ public:
     virtual Solid::OpticalDisc::DiscType discType() const;
     virtual Solid::OpticalDisc::ContentTypes availableContent() const;
 
-private Q_SLOTS:
-    void slotDrivePropertiesChanged(const QString & ifaceName, const QVariantMap & changedProps, const QStringList & invalidatedProps);
-
 private:
     QString media() const;
-    mutable bool m_needsReprobe;
-    mutable Solid::OpticalDisc::ContentTypes m_cachedContent;
     Device * m_drive;
     UdevQt::Device m_udevDevice;
+    QDBusInterface *m_scanner;
 };
 
 }
diff --git a/solid/solid/backends/udisks2/udisksopticaldisc.cpp b/solid/solid/backends/udisks2/udisksopticaldisc.cpp
index 23a4fc1..e17d75b 100644
--- a/solid/solid/backends/udisks2/udisksopticaldisc.cpp
+++ b/solid/solid/backends/udisks2/udisksopticaldisc.cpp
@@ -19,161 +19,20 @@
     License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */
 
-#include <sys/types.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-
-#include <QtCore/QFile>
 #include <QtCore/QMap>
-#include <QtCore/QMutexLocker>
 #include <QtDBus/QDBusConnection>
 
 #include "../shared/udevqt.h"
 
 #include "udisks2.h"
 #include "udisksopticaldisc.h"
-#include "soliddefs_p.h"
-
-typedef QMap<QByteArray, Solid::OpticalDisc::ContentTypes> ContentTypesCache;
-SOLID_GLOBAL_STATIC(ContentTypesCache, cache)
-SOLID_GLOBAL_STATIC(QMutex, cacheLock)
-
-// inspired by http://cgit.freedesktop.org/hal/tree/hald/linux/probing/probe-volume.c
-static Solid::OpticalDisc::ContentType advancedDiscDetect(const QByteArray & device_file)
-{
-    /* the discs block size */
-    unsigned short bs;
-    /* the path table size */
-    unsigned short ts;
-    /* the path table location (in blocks) */
-    unsigned int tl;
-    /* length of the directory name in current path table entry */
-    unsigned char len_di = 0;
-    /* the number of the parent directory's path table entry */
-    unsigned int parent = 0;
-    /* filename for the current path table entry */
-    char dirname[256];
-    /* our position into the path table */
-    int pos = 0;
-    /* the path table record we're on */
-    int curr_record = 1;
-
-    Solid::OpticalDisc::ContentType result = Solid::OpticalDisc::NoContent;
-
-    int fd = open(device_file.constData(), O_RDONLY);
-
-    /* read the block size */
-    lseek (fd, 0x8080, SEEK_CUR);
-    if (read (fd, &bs, 2) != 2)
-    {
-        qDebug("Advanced probing on %s failed while reading block size", qPrintable(device_file));
-        goto out;
-    }
-
-    /* read in size of path table */
-    lseek (fd, 2, SEEK_CUR);
-    if (read (fd, &ts, 2) != 2)
-    {
-        qDebug("Advanced probing on %s failed while reading path table size", qPrintable(device_file));
-        goto out;
-    }
-
-    /* read in which block path table is in */
-    lseek (fd, 6, SEEK_CUR);
-    if (read (fd, &tl, 4) != 4)
-    {
-        qDebug("Advanced probing on %s failed while reading path table block", qPrintable(device_file));
-        goto out;
-    }
-
-    /* seek to the path table */
-    lseek (fd, bs * tl, SEEK_SET);
-
-    /* loop through the path table entries */
-    while (pos < ts)
-    {
-        /* get the length of the filename of the current entry */
-        if (read (fd, &len_di, 1) != 1)
-        {
-            qDebug("Advanced probing on %s failed, cannot read more entries", qPrintable(device_file));
-            break;
-        }
-
-        /* get the record number of this entry's parent
-           i'm pretty sure that the 1st entry is always the top directory */
-        lseek (fd, 5, SEEK_CUR);
-        if (read (fd, &parent, 2) != 2)
-        {
-            qDebug("Advanced probing on %s failed, couldn't read parent entry", qPrintable(device_file));
-            break;
-        }
-
-        /* read the name */
-        if (read (fd, dirname, len_di) != len_di)
-        {
-            qDebug("Advanced probing on %s failed, couldn't read the entry name", qPrintable(device_file));
-            break;
-        }
-        dirname[len_di] = 0;
-
-        /* if we found a folder that has the root as a parent, and the directory name matches
-           one of the special directories then set the properties accordingly */
-        if (parent == 1)
-        {
-            if (!strcasecmp (dirname, "VIDEO_TS"))
-            {
-                qDebug("Disc in %s is a Video DVD", qPrintable(device_file));
-                result = Solid::OpticalDisc::VideoDvd;
-                break;
-            }
-            else if (!strcasecmp (dirname, "BDMV"))
-            {
-                qDebug("Disc in %s is a Blu-ray video disc", qPrintable(device_file));
-                result = Solid::OpticalDisc::VideoBluRay;
-                break;
-            }
-            else if (!strcasecmp (dirname, "VCD"))
-            {
-                qDebug("Disc in %s is a Video CD", qPrintable(device_file));
-                result = Solid::OpticalDisc::VideoCd;
-                break;
-            }
-            else if (!strcasecmp (dirname, "SVCD"))
-            {
-                qDebug("Disc in %s is a Super Video CD", qPrintable(device_file));
-                result = Solid::OpticalDisc::SuperVideoCd;
-                break;
-            }
-        }
-
-        /* all path table entries are padded to be even,
-           so if this is an odd-length table, seek a byte to fix it */
-        if (len_di%2 == 1)
-        {
-            lseek (fd, 1, SEEK_CUR);
-            pos++;
-        }
-
-        /* update our position */
-        pos += 8 + len_di;
-        curr_record++;
-    }
-
-    close(fd);
-    return result;
-
-out:
-    /* go back to the start of the file */
-    lseek (fd, 0, SEEK_SET);
-    close(fd);
-    return result;
-}
 
 using namespace Solid::Backends::UDisks2;
 
+static const int diskScannerTimeout = 5 * 60 * 1000; //Timeout for D-Bus communication, not for reading disk
+
 OpticalDisc::OpticalDisc(Device *dev)
-    : StorageVolume(dev), m_needsReprobe(true), m_cachedContent(Solid::OpticalDisc::NoContent)
+    : StorageVolume(dev)
 {
     UdevQt::Client client(this);
     m_udevDevice = client.deviceByDeviceFile(device());
@@ -181,8 +40,9 @@ OpticalDisc::OpticalDisc(Device *dev)
     /*qDebug() << "\tProperties:" << */ m_udevDevice.deviceProperties(); // initialize the properties DB so that it doesn't crash further down, #298416
 
     m_drive = new Device(m_device->drivePath());
-    QDBusConnection::systemBus().connect(UD2_DBUS_SERVICE, m_drive->udi(), DBUS_INTERFACE_PROPS, "PropertiesChanged", this,
-                                         SLOT(slotDrivePropertiesChanged(QString,QVariantMap,QStringList)));
+    m_scanner = new QDBusInterface("org.kde.Solid.DiskScanner", "/", "",
+                                   QDBusConnection::sessionBus(), this);
+    m_scanner->setTimeout(diskScannerTimeout);
 }
 
 OpticalDisc::~OpticalDisc()
@@ -245,52 +105,28 @@ Solid::OpticalDisc::DiscType OpticalDisc::discType() const
 
 Solid::OpticalDisc::ContentTypes OpticalDisc::availableContent() const
 {
-    if (isBlank()) {
-        m_needsReprobe = false;
-        return Solid::OpticalDisc::NoContent;
-    }
-
-    if (m_needsReprobe) {
-        QMutexLocker lock(cacheLock);
-
-        const QByteArray deviceFile = m_device->prop("Device").toByteArray();
-
-        if (cache->contains(deviceFile)) {
-            m_cachedContent = cache->value(deviceFile);
-            m_needsReprobe = false;
-            return m_cachedContent;
-        }
-
-        m_cachedContent = Solid::OpticalDisc::NoContent;
+    Solid::OpticalDisc::ContentTypes m_cachedContent = Solid::OpticalDisc::NoContent;
+    if (!isBlank()) {
         const bool hasData = m_drive->prop("OpticalNumDataTracks").toUInt() > 0;
         const bool hasAudio = m_drive->prop("OpticalNumAudioTracks").toUInt() > 0;
 
         if ( hasData ) {
             m_cachedContent |= Solid::OpticalDisc::Data;
-            m_cachedContent |= advancedDiscDetect(deviceFile);
+            QDBusReply<int> reply = m_scanner->call("getContent", m_device->udi(),
+                                                    m_device->prop("Device").toString());
+            if (!reply.isValid()) {
+                qCritical() << "Can't call org.kde.Solid.DiskScanner: " << reply.error();
+            } else {
+                m_cachedContent |= static_cast<Solid::OpticalDisc::ContentTypes>(reply.value());
+            }
         }
         if ( hasAudio )
             m_cachedContent |= Solid::OpticalDisc::Audio;
-
-        m_needsReprobe = false;
-        cache->insert(deviceFile, m_cachedContent);
     }
 
     return m_cachedContent;
 }
 
-void OpticalDisc::slotDrivePropertiesChanged(const QString &ifaceName, const QVariantMap &changedProps, const QStringList &invalidatedProps)
-{
-    Q_UNUSED(ifaceName);
-
-    if (changedProps.keys().contains("Media") || invalidatedProps.contains("Media")) {
-        QMutexLocker lock(cacheLock);
-        m_needsReprobe = true;
-        m_cachedContent = Solid::OpticalDisc::NoContent;
-        cache->remove(m_device->prop("Device").toByteArray());
-    }
-}
-
 QString OpticalDisc::media() const
 {
     return m_drive->prop("Media").toString();
diff --git a/solid/solid/diskscan/CMakeLists.txt b/solid/solid/diskscan/CMakeLists.txt
new file mode 100644
index 0000000..f7f5093
--- /dev/null
+++ b/solid/solid/diskscan/CMakeLists.txt
@@ -0,0 +1,24 @@
+message(STATUS "Building Solid Disk Scanner daemon." )
+
+set(soliddiskscan_SRCS
+diskscanner.cpp
+diskscannertask.cpp
+)
+
+kde4_add_executable(soliddiskscan ${soliddiskscan_SRCS})
+
+target_link_libraries(soliddiskscan
+${QT_QTCORE_LIBRARY}
+${QT_QTDBUS_LIBRARY}
+${QT_QTGUI_LIBRARY}
+${KDE4_SOLID_LIBS}
+)
+
+install(TARGETS soliddiskscan DESTINATION ${LIBEXEC_INSTALL_DIR})
+
+#D-Bus activation
+configure_file(org.kde.Solid.DiskScanner.service.cmake
+${CMAKE_CURRENT_BINARY_DIR}/org.kde.Solid.DiskScanner.service)
+
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/org.kde.Solid.DiskScanner.service
+DESTINATION ${DBUS_SERVICES_INSTALL_DIR})
diff --git a/solid/solid/diskscan/diskscanner.h b/solid/solid/diskscan/diskscanner.h
new file mode 100644
index 0000000..d6d590b
--- /dev/null
+++ b/solid/solid/diskscan/diskscanner.h
@@ -0,0 +1,56 @@
+/*
+    Copyright 2013 Alexander Mezin <mezin.alexander@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef DISKSCANNER_H
+#define DISKSCANNER_H
+
+#include <QtCore/QMultiMap>
+#include <QtCore/QString>
+#include <QtCore/QThreadPool>
+#include <QtDBus/QDBusContext>
+#include <QtDBus/QDBusMessage>
+
+#include <solid/opticaldisc.h>
+
+class DiskScanner : public QObject,
+                    protected QDBusContext
+{
+    Q_OBJECT
+    Q_CLASSINFO("D-Bus Interface", "org.kde.Solid.DiskScanner")
+
+public:
+    DiskScanner();
+    virtual ~DiskScanner();
+
+public Q_SLOTS:
+    int getContent(const QString& udi, const QString& file);
+
+private Q_SLOTS:
+    void deviceRemoved(const QString& device);
+    void taskDone(const QString &udi, Solid::OpticalDisc::ContentTypes content, bool diskFound);
+
+private:
+    QMap<QString, Solid::OpticalDisc::ContentTypes> m_content;
+    QMultiMap<QString, QDBusMessage> m_delayed;
+    QThreadPool m_threadPool;
+};
+
+#endif // DISKSCANNER_H
+// kate: indent-mode cstyle; indent-width 4; replace-tabs on; 
diff --git a/solid/solid/diskscan/diskscanner.cpp b/solid/solid/diskscan/diskscanner.cpp
new file mode 100644
index 0000000..52ec393
--- /dev/null
+++ b/solid/solid/diskscan/diskscanner.cpp
@@ -0,0 +1,105 @@
+/*
+    Copyright 2013 Alexander Mezin <mezin.alexander@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "diskscanner.h"
+
+#include <QtCore/QDebug>
+#include <QtDBus/QDBusConnection>
+#include <QtDBus/QDBusMessage>
+#include <QtGui/QApplication>
+
+#include <solid/devicenotifier.h>
+
+#include "diskscannertask.h"
+
+DiskScanner::DiskScanner()
+{
+    connect(Solid::DeviceNotifier::instance(), SIGNAL(deviceRemoved(QString)), this, SLOT(deviceRemoved(QString)));
+}
+
+DiskScanner::~DiskScanner()
+{
+
+}
+
+void DiskScanner::deviceRemoved(const QString& device)
+{
+    qDebug() << "Removed device " << device;
+    if (m_content.remove(device)) {
+        qDebug() << "Removed from cache " << device;
+    }
+}
+
+int DiskScanner::getContent(const QString& udi, const QString& file)
+{
+    Q_ASSERT(calledFromDBus());
+
+    qDebug() << "Request for " << udi << ", " << file;
+    if (m_content.contains(udi)) {
+        qDebug() << udi << " found in cache";
+        return m_content.value(udi);
+    }
+
+    if (!m_delayed.contains(udi)) {
+        DiskScannerTask* newTask = new DiskScannerTask(udi, file);
+        connect(newTask, SIGNAL(done(QString,Solid::OpticalDisc::ContentTypes,bool)),
+                this, SLOT(taskDone(QString,Solid::OpticalDisc::ContentTypes,bool)),
+                Qt::BlockingQueuedConnection);
+
+        //Don't limit thread count (maybe there is a better way?)
+        while (!m_threadPool.tryStart(newTask))
+            m_threadPool.setMaxThreadCount(m_threadPool.maxThreadCount() + 1);
+    }
+
+    m_delayed.insertMulti(udi, message());
+    setDelayedReply(true);
+    return Solid::OpticalDisc::NoContent;
+}
+
+void DiskScanner::taskDone(const QString& udi, Solid::OpticalDisc::ContentTypes content, bool diskFound)
+{
+    if (diskFound) {
+        m_content.insert(udi, content);
+    }
+
+    QMultiMap<QString, QDBusMessage>::Iterator begin = m_delayed.lowerBound(udi),
+                                               end = m_delayed.upperBound(udi);
+    for (QMultiMap<QString, QDBusMessage>::Iterator i = begin; i != end; i++) {
+        QDBusConnection::sessionBus().send(i->createReply(static_cast<int>(content)));
+    }
+    m_delayed.remove(udi);
+}
+
+int main(int argc, char *argv[])
+{
+    if (!QDBusConnection::sessionBus().registerService("org.kde.Solid.DiskScanner")) {
+        qFatal("Can't register service org.kde.Solid.DiskScanner");
+    }
+
+    DiskScanner scanner;
+    if (!QDBusConnection::sessionBus().registerObject("/", &scanner, QDBusConnection::ExportAllContents)) {
+        qFatal("Can't register object org.kde.Solid.DiskScanner /");
+    }
+
+    //If someone told me, how to detect disconnection from session bus, this could be replaced with QCoreApplication
+    return QApplication(argc, argv, true).exec();
+}
+
+// kate: indent-mode cstyle; indent-width 4; replace-tabs on; 
diff --git a/solid/solid/diskscan/diskscannertask.h b/solid/solid/diskscan/diskscannertask.h
new file mode 100644
index 0000000..efd5f41
--- /dev/null
+++ b/solid/solid/diskscan/diskscannertask.h
@@ -0,0 +1,45 @@
+/*
+    Copyright 2013 Alexander Mezin <mezin.alexander@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef DISKSCANNERTASK_H
+#define DISKSCANNERTASK_H
+
+#include <QtCore/QRunnable>
+#include <QtCore/QString>
+
+#include <solid/opticaldisc.h>
+
+class DiskScannerTask : public QObject, public QRunnable
+{
+Q_OBJECT
+
+public:
+    DiskScannerTask(const QString &udi, const QString &file);
+    virtual void run();
+
+Q_SIGNALS:
+    void done(const QString &udi, Solid::OpticalDisc::ContentTypes content, bool diskFound);
+
+private:
+    QString m_udi;
+    QString m_file;
+};
+
+#endif // DISKSCANNERTASK_H
diff --git a/solid/solid/diskscan/diskscannertask.cpp b/solid/solid/diskscan/diskscannertask.cpp
new file mode 100644
index 0000000..03b0793
--- /dev/null
+++ b/solid/solid/diskscan/diskscannertask.cpp
@@ -0,0 +1,155 @@
+/*
+    Copyright 2013 Alexander Mezin <mezin.alexander@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "diskscannertask.h"
+
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <QtCore/QFile>
+#include <QtCore/QDebug>
+
+//Taken from solid/backends/udisks/udisksopticaldisk.cpp
+static bool advancedDiscDetect(const QString& device_file, Solid::OpticalDisc::ContentType &result)
+{
+    /* the discs block size */
+    unsigned short bs;
+    /* the path table size */
+    unsigned short ts;
+    /* the path table location (in blocks) */
+    unsigned int tl;
+    /* length of the directory name in current path table entry */
+    unsigned char len_di = 0;
+    /* the number of the parent directory's path table entry */
+    unsigned int parent = 0;
+    /* filename for the current path table entry */
+    char dirname[256];
+    /* our position into the path table */
+    int pos = 0;
+    /* the path table record we're on */
+    int curr_record = 1;
+
+    int fd = open(QFile::encodeName(device_file), O_RDONLY);
+    if (fd == -1)
+        return false;
+
+    /* read the block size */
+    lseek(fd, 0x8080, SEEK_CUR);
+    if (read(fd, &bs, 2) != 2) {
+        qWarning("Advanced probing on %s failed while reading block size", qPrintable(device_file));
+        goto out;
+    }
+
+    /* read in size of path table */
+    lseek(fd, 2, SEEK_CUR);
+    if (read(fd, &ts, 2) != 2) {
+        qWarning("Advanced probing on %s failed while reading path table size", qPrintable(device_file));
+        goto out;
+    }
+
+    /* read in which block path table is in */
+    lseek(fd, 6, SEEK_CUR);
+    if (read(fd, &tl, 4) != 4) {
+        qWarning("Advanced probing on %s failed while reading path table block", qPrintable(device_file));
+        goto out;
+    }
+
+    /* seek to the path table */
+    lseek(fd, bs * tl, SEEK_SET);
+
+    /* loop through the path table entries */
+    while (pos < ts) {
+        /* get the length of the filename of the current entry */
+        if (read(fd, &len_di, 1) != 1) {
+            qWarning("Advanced probing on %s failed, cannot read more entries", qPrintable(device_file));
+            break;
+        }
+
+        /* get the record number of this entry's parent
+           i'm pretty sure that the 1st entry is always the top directory */
+        lseek(fd, 5, SEEK_CUR);
+        if (read(fd, &parent, 2) != 2) {
+            qWarning("Advanced probing on %s failed, couldn't read parent entry", qPrintable(device_file));
+            break;
+        }
+
+        /* read the name */
+        if (read(fd, dirname, len_di) != len_di) {
+            qWarning("Advanced probing on %s failed, couldn't read the entry name", qPrintable(device_file));
+            break;
+        }
+        dirname[len_di] = 0;
+
+        /* if we found a folder that has the root as a parent, and the directory name matches
+           one of the special directories then set the properties accordingly */
+        if (parent == 1) {
+            if (!strcasecmp(dirname, "VIDEO_TS")) {
+                qDebug("Disc in %s is a Video DVD", qPrintable(device_file));
+                result = Solid::OpticalDisc::VideoDvd;
+                break;
+            } else if (!strcasecmp(dirname, "BDMV")) {
+                qDebug("Disc in %s is a Blu-ray video disc", qPrintable(device_file));
+                result = Solid::OpticalDisc::VideoBluRay;
+                break;
+            } else if (!strcasecmp(dirname, "VCD")) {
+                qDebug("Disc in %s is a Video CD", qPrintable(device_file));
+                result = Solid::OpticalDisc::VideoCd;
+                break;
+            } else if (!strcasecmp(dirname, "SVCD")) {
+                qDebug("Disc in %s is a Super Video CD", qPrintable(device_file));
+                result = Solid::OpticalDisc::SuperVideoCd;
+                break;
+            }
+        }
+
+        /* all path table entries are padded to be even,
+           so if this is an odd-length table, seek a byte to fix it */
+        if (len_di % 2 == 1) {
+            lseek(fd, 1, SEEK_CUR);
+            pos++;
+        }
+
+        /* update our position */
+        pos += 8 + len_di;
+        curr_record++;
+    }
+out:
+    /* go back to the start of the file */
+    lseek(fd, 0, SEEK_SET);
+    close(fd);
+    return true;
+}
+
+DiskScannerTask::DiskScannerTask(const QString &udi, const QString &file)
+: m_udi(udi), m_file(file)
+{
+    qDebug() << "New task: " << m_udi << " file: " << m_file;
+}
+
+void DiskScannerTask::run()
+{
+    qDebug() << "Running task " << m_udi << " file: " << m_file;
+    Solid::OpticalDisc::ContentType content = Solid::OpticalDisc::NoContent;
+    bool diskFound = advancedDiscDetect(m_file, content);
+    qDebug() << "Emitting done(" << m_udi << ", " << content << ", " << diskFound << ")";
+    Q_EMIT done(m_udi, content, diskFound);
+}
diff --git a/solid/solid/diskscan/org.kde.Solid.DiskScanner.service.cmake b/solid/solid/diskscan/org.kde.Solid.DiskScanner.service.cmake
new file mode 100644
index 0000000..2656ee9
--- /dev/null
+++ b/solid/solid/diskscan/org.kde.Solid.DiskScanner.service.cmake
@@ -0,0 +1,3 @@
+[D-BUS Service]
+Name=org.kde.Solid.DiskScanner
+Exec=@LIBEXEC_INSTALL_DIR@/soliddiskscan
